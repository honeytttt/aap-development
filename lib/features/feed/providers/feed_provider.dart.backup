import 'package:flutter/foundation.dart';
import 'package:workout_app/core/models/post.dart';
import 'package:workout_app/core/models/comment.dart';

class FeedProvider with ChangeNotifier {
  List<Post> _posts = [];
  CommentThread _commentThread = CommentThread(
    topLevelComments: [],
    allComments: {},
  );
  bool _isLoading = false;
  String? _replyingToCommentId; // Track which comment we're replying to

  List<Post> get posts => _posts;
  List<Comment> get comments => _commentThread.flattenedComments;
  List<Comment> get topLevelComments => _commentThread.topLevelComments;
  bool get isLoading => _isLoading;
  String? get replyingToCommentId => _replyingToCommentId;

  FeedProvider() {
    _loadMockData();
  }

  void _loadMockData() {
    _isLoading = true;
    notifyListeners();

    // Mock posts
    _posts = [
      Post(
        id: '1',
        userId: 'user1',
        userName: 'Yoga Enthusiast',
        userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=YE',
        content: 'Just completed a peaceful morning yoga session. Feeling energized and ready for the day!',
        images: [],
        createdAt: DateTime.now().subtract(const Duration(hours: 2)),
        likes: 42,
        likedBy: ['user2', 'user3'],
        commentCount: 7, // Updated for nested comments
      ),
      Post(
        id: '2',
        userId: 'user2',
        userName: 'Meditation Guide',
        userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=MG',
        content: '10 minutes of mindful breathing can transform your entire day. Try it!',
        images: [],
        createdAt: DateTime.now().subtract(const Duration(days: 1)),
        likes: 89,
        likedBy: ['user1'],
        commentCount: 15, // Updated for nested comments
      ),
    ];

    // Mock comments with nested replies
    final comment1 = Comment(
      id: 'c1',
      postId: '1',
      userId: 'user2',
      userName: 'Meditation Guide',
      userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=MG',
      content: 'Great job! Yoga truly changes lives.',
      createdAt: DateTime.now().subtract(const Duration(hours: 1)),
      likes: 5,
      likedBy: ['user1', 'user3'],
      depth: 0,
    );

    final reply1 = Comment(
      id: 'c1r1',
      postId: '1',
      userId: 'user3',
      userName: 'Wellness Warrior',
      userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=WW',
      content: 'Which yoga poses did you focus on today?',
      createdAt: DateTime.now().subtract(const Duration(minutes: 45)),
      likes: 2,
      parentCommentId: 'c1',
      depth: 1,
    );

    final reply2 = Comment(
      id: 'c1r2',
      postId: '1',
      userId: 'user1',
      userName: 'Yoga Enthusiast',
      userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=YE',
      content: 'Mostly sun salutations and warrior poses. They really help build strength and flexibility!',
      createdAt: DateTime.now().subtract(const Duration(minutes: 30)),
      likes: 3,
      parentCommentId: 'c1',
      depth: 1,
    );

    final replyToReply = Comment(
      id: 'c1r1r1',
      postId: '1',
      userId: 'user2',
      userName: 'Meditation Guide',
      userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=MG',
      content: 'I love warrior poses too! They build such great mental focus.',
      createdAt: DateTime.now().subtract(const Duration(minutes: 15)),
      likes: 1,
      parentCommentId: 'c1r1',
      depth: 2,
    );

    // Build nested structure
    final comment1WithReplies = comment1
        .addReply(reply1.addReply(replyToReply))
        .addReply(reply2);

    final comment2 = Comment(
      id: 'c2',
      postId: '1',
      userId: 'user4',
      userName: 'Mindful Runner',
      userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=MR',
      content: 'Do you have any tips for beginners?',
      createdAt: DateTime.now().subtract(const Duration(minutes: 20)),
      likes: 1,
      depth: 0,
    );

    final comment2Reply = Comment(
      id: 'c2r1',
      postId: '1',
      userId: 'user1',
      userName: 'Yoga Enthusiast',
      userAvatar: 'https://via.placeholder.com/150/4CAF50/FFFFFF?text=YE',
      content: 'Start with basic poses and focus on breath. Don\'t push too hard!',
      createdAt: DateTime.now().subtract(const Duration(minutes: 10)),
      likes: 2,
      parentCommentId: 'c2',
      depth: 1,
    );

    final comment2WithReplies = comment2.addReply(comment2Reply);

    // Initialize comment thread
    _commentThread = CommentThread(
      topLevelComments: [comment1WithReplies, comment2WithReplies],
      allComments: {
        'c1': comment1WithReplies,
        'c1r1': reply1.addReply(replyToReply),
        'c1r1r1': replyToReply,
        'c1r2': reply2,
        'c2': comment2WithReplies,
        'c2r1': comment2Reply,
      },
    );

    Future.delayed(const Duration(milliseconds: 500), () {
      _isLoading = false;
      notifyListeners();
    });
  }

  void likePost(String postId, String userId) {
    final index = _posts.indexWhere((post) => post.id == postId);
    if (index != -1) {
      final post = _posts[index];
      if (post.likedBy.contains(userId)) {
        // Unlike
        _posts[index] = post.copyWith(
          likes: post.likes - 1,
          likedBy: List<String>.from(post.likedBy)..remove(userId),
        );
      } else {
        // Like
        _posts[index] = post.copyWith(
          likes: post.likes + 1,
          likedBy: List<String>.from(post.likedBy)..add(userId),
        );
      }
      notifyListeners();
    }
  }

  void addComment({
    required String postId,
    required String userId,
    required String userName,
    required String userAvatar,
    required String content,
    String? parentCommentId,
  }) {
    final newComment = Comment(
      id: 'c${DateTime.now().millisecondsSinceEpoch}',
      postId: postId,
      userId: userId,
      userName: userName,
      userAvatar: userAvatar,
      content: content,
      createdAt: DateTime.now(),
      likes: 0,
      likedBy: [],
      parentCommentId: parentCommentId,
      depth: parentCommentId == null ? 0 : (_getCommentDepth(parentCommentId) + 1),
    );

    _commentThread = _commentThread.addComment(newComment);

    // Update post comment count
    final postIndex = _posts.indexWhere((post) => post.id == postId);
    if (postIndex != -1) {
      final post = _posts[postIndex];
      _posts[postIndex] = post.copyWith(
        commentCount: post.commentCount + 1,
      );
    }

    // Clear reply mode if active
    if (_replyingToCommentId != null) {
      _replyingToCommentId = null;
    }

    notifyListeners();
  }

  void likeComment(String commentId, String userId) {
    final comment = _commentThread.allComments[commentId];
    if (comment != null) {
      final updatedComment = comment.toggleLike(userId);
      _updateCommentInThread(updatedComment);
    }
  }

  void toggleCommentExpanded(String commentId) {
    final comment = _commentThread.allComments[commentId];
    if (comment != null) {
      final updatedComment = comment.toggleExpanded();
      _updateCommentInThread(updatedComment);
    }
  }

  void setReplyingTo(String? commentId) {
    _replyingToCommentId = commentId;
    notifyListeners();
  }

  // Helper methods
  int _getCommentDepth(String commentId) {
    final comment = _commentThread.allComments[commentId];
    return comment?.depth ?? 0;
  }

  void _updateCommentInThread(Comment updatedComment) {
    final newAllComments = Map<String, Comment>.from(_commentThread.allComments);
    newAllComments[updatedComment.id] = updatedComment;

    // Update parent if this is a reply
    if (updatedComment.parentCommentId != null) {
      final parent = newAllComments[updatedComment.parentCommentId!];
      if (parent != null) {
        // Find and update this reply in parent's replies
        final updatedReplies = parent.replies.map((reply) => 
          reply.id == updatedComment.id ? updatedComment : reply
        ).toList();
        
        final updatedParent = parent.copyWith(replies: updatedReplies);
        newAllComments[updatedParent.id] = updatedParent;
      }
    }

    // Update top-level comments
    List<Comment> updatedTopLevel = _commentThread.topLevelComments;
    if (updatedComment.parentCommentId == null) {
      // This is a top-level comment
      updatedTopLevel = _commentThread.topLevelComments.map((c) => 
        c.id == updatedComment.id ? updatedComment : c
      ).toList();
    } else {
      // Check if parent is top-level and update it
      final parent = newAllComments[updatedComment.parentCommentId!];
      if (parent?.parentCommentId == null) {
        updatedTopLevel = _commentThread.topLevelComments.map((c) => 
          c.id == parent!.id ? parent : c
        ).toList();
      }
    }

    _commentThread = CommentThread(
      topLevelComments: updatedTopLevel,
      allComments: newAllComments,
    );
    
    notifyListeners();
  }

  // Get replies for a specific comment
  List<Comment> getRepliesForComment(String commentId) {
    final comment = _commentThread.allComments[commentId];
    return comment?.replies ?? [];
  }

  // Check if user has liked a comment
  bool hasUserLikedComment(String commentId, String userId) {
    final comment = _commentThread.allComments[commentId];
    return comment?.likedBy.contains(userId) ?? false;
  }
}
